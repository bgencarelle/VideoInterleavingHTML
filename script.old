// script.js

// Configuration Constants
const FPS = 30;
const FRAME_DURATION = 1000 / FPS;
const BUFFER_SIZE = FPS; // Adjusted to a manageable size based on performance
const PINGPONG = true; // Enabled to allow ping-pong indexing
const CLOCK_MODE = 'FREE_CLOCK'; // As per your Python code

// Paths to JSON files generated by the Python script
const MAIN_IMAGES_JSON = 'generated_img_lists/main_images.json';
const FLOAT_IMAGES_JSON = 'generated_img_lists/float_images.json';

// Loaded Folder Lists
let mainFolders = [];
let floatFolders = [];

// Unified Buffer for Preloading Image Pairs
let imageBuffer = [];

// Index Variables
let overallIndex = 0; // Used for rendering
let preloadIndex = 0; // Used for preloading
let direction = 1; // 1 for forward, -1 for backward

// Folder Count (Ensuring Both Layers Have the Same Number of Folders)
let folderCount = 0;

// Image Cache to Store Loaded Images
const imageCache = new Map();

// Additional Variables for Folder Changes
let rand_mult = getRandomInt(1, 9);
let rand_start = 5 * (FPS - Math.floor((rand_mult * rand_mult) / 2));
let float_folder = 0;
let main_folder = 0;

// Canvas Setup
const canvas = document.getElementById('displayCanvas');
const ctx = canvas.getContext('2d');

// Off-Screen Canvas for Pre-Mixing Images
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d');

// Initialize Canvas and Off-Screen Canvas
function initializeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    offscreenCanvas.width = canvas.width;
    offscreenCanvas.height = canvas.height;
}
window.addEventListener('resize', initializeCanvas);
initializeCanvas();

// Fullscreen Handling
const fullscreenButton = document.getElementById('fullscreenButton');

function requestFullscreen() {
    const element = document.documentElement; // Fullscreen the entire page
    if (element.requestFullscreen) {
        element.requestFullscreen();
    } else if (element.mozRequestFullScreen) { // Firefox
        element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) { // Chrome, Safari, and Opera
        element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) { // IE/Edge
        element.msRequestFullscreen();
    }
}

// Attempt to request fullscreen on load
window.addEventListener('load', () => {
    requestFullscreen();
});

// Show fallback button if fullscreen is not active
document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
        fullscreenButton.style.display = 'block';
    } else {
        fullscreenButton.style.display = 'none';
    }
});

// Event listener for the fallback fullscreen button
fullscreenButton.addEventListener('click', () => {
    requestFullscreen();
    fullscreenButton.style.display = 'none';
});

// Utility Function to Fetch JSON Data
async function fetchJSON(path) {
    try {
        const response = await fetch(path);
        if (!response.ok) {
            throw new Error(`Failed to load ${path}: ${response.statusText}`);
        }
        return await response.json();
    } catch (error) {
        console.error(error);
        return { folders: [] };
    }
}

// Utility Function to Load an Image with Caching
function loadImage(path) {
    return new Promise((resolve) => {
        if (imageCache.has(path)) {
            resolve(imageCache.get(path));
            return;
        }

        // Encode the path to handle special characters
        const encodedPath = encodeURI(path);

        const img = new Image();
        img.src = encodedPath;
        img.onload = () => {
            imageCache.set(path, img);
            resolve(img);
        };
        img.onerror = () => {
            console.error(`Failed to load image: ${path}`);
            resolve(null); // Skip this image
        };
    });
}

// Function to Update Folders Based on Rules
function updateFolders(index) {
    // Reset conditions
    if (
        (index > 0 && index < rand_start) ||
        (index > (100 * rand_start) && index < (140 * rand_start))
    ) {
        float_folder = 0;
        main_folder = 0;
    }
    // Change float folder at intervals
    else if (index % (FPS * rand_mult) === 0) {
        float_folder = getRandomInt(0, floatFolders.length - 1);
        rand_mult = getRandomInt(1, 12); // Update random multiplier
        // Recalculate rand_start after updating rand_mult
        rand_start = 8 * (FPS - Math.floor((rand_mult * rand_mult) / 2));
    }
    // Change main folder at different intervals
    else if (index % (2 * FPS * rand_mult - 1) === 0) {
        main_folder = getRandomInt(0, mainFolders.length - 1);
    }
}

// Function to Preload Image Pairs into the Buffer
async function preloadImages() {
    while (imageBuffer.length < BUFFER_SIZE) {
        const { fgPath, bgPath } = getImagePathsAtIndex(preloadIndex);
        const fgImg = await loadImage(fgPath);
        const bgImg = await loadImage(bgPath);
        if (fgImg && bgImg) {
            imageBuffer.push({ fgImg, bgImg, index: preloadIndex });
            preloadIndex += direction;
        } else {
            // If images failed to load, skip to the next index
            preloadIndex += direction;
        }

        // Handle preloadIndex wrapping at boundaries
        const maxIndex = getMaxIndex();
        if (preloadIndex > maxIndex) {
            preloadIndex = maxIndex;
            direction = -1; // Reverse direction
        } else if (preloadIndex < 0) {
            preloadIndex = 0;
            direction = 1; // Reverse direction
        }
    }
}

// Function to Get Image Paths at a Specific Index
function getImagePathsAtIndex(index) {
    const fgFolder = mainFolders[main_folder];
    const bgFolder = floatFolders[float_folder];
    const fgImages = fgFolder.image_list;
    const bgImages = bgFolder.image_list;

    const fgMaxIndex = fgImages.length - 1;
    const bgMaxIndex = bgImages.length - 1;
    const maxIndex = Math.min(fgMaxIndex, bgMaxIndex);

    let idx = index;

    if (idx < 0) {
        idx = 0;
    } else if (idx > maxIndex) {
        idx = maxIndex;
    }

    const fgIndex = idx % fgImages.length;
    const bgIndex = idx % bgImages.length;
    const fgPath = fgImages[fgIndex];
    const bgPath = bgImages[bgIndex];
    return { fgPath, bgPath };
}

// Function to Get Maximum Index Based on Current Folders
function getMaxIndex() {
    const fgFolder = mainFolders[main_folder];
    const bgFolder = floatFolders[float_folder];
    return Math.min(fgFolder.image_list.length, bgFolder.image_list.length) - 1;
}

// Variables to Track FPS
let frameTimes = [];
let fps = 0;

// Render Loop Function
async function renderLoop(timestamp) {
    if (!this.lastFrameTime) this.lastFrameTime = timestamp;
    const elapsed = timestamp - this.lastFrameTime;

    // Update FPS Calculation
    const deltaTime = timestamp - this.lastFrameTime;
    frameTimes.push(deltaTime);
    if (frameTimes.length > 60) frameTimes.shift();
    const averageDeltaTime = frameTimes.reduce((sum, time) => sum + time, 0) / frameTimes.length;
    fps = (1000 / averageDeltaTime).toFixed(1);

    if (elapsed >= FRAME_DURATION) {
        this.lastFrameTime = timestamp;

        // Only proceed if the buffer has images ready
        if (imageBuffer.length > 0) {
            const nextImages = imageBuffer.shift();
            const { fgImg, bgImg, index } = nextImages;

            // Update folders based on the rules
            updateFolders(index);

            // Extract file names from paths (for display)
            const fgName = fgImg.src.split('/').pop();
            const bgName = bgImg.src.split('/').pop();

            // Pre-Mix Images on Off-Screen Canvas
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            drawImageWithAspect(offscreenCtx, fgImg); // Draw Foreground First
            drawImageWithAspect(offscreenCtx, bgImg); // Draw Floatground on Top

            // Clear the Main Canvas (Optional)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Pre-Mixed Image onto Main Canvas
            ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);

            // Draw Text Overlay using 'index'
            ctx.font = '16px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.fillText(`Index: ${index}, Direction: ${direction === 1 ? 'Forward' : 'Backward'}`, canvas.width - 10, canvas.height - 70);
            ctx.fillText(`Foreground: ${fgName}`, canvas.width - 10, canvas.height - 50);
            ctx.fillText(`Floatground: ${bgName}`, canvas.width - 10, canvas.height - 30);
            ctx.fillText(`FPS: ${fps}`, canvas.width - 10, canvas.height - 10);

            // Update overallIndex to the index of the displayed image
            overallIndex = index;

            // Determine maximum index based on current folders
            const maxIndex = getMaxIndex();

            // Reverse direction at the ends and reset preloadIndex
            if (direction === 1 && overallIndex >= maxIndex) {
                direction = -1;
                preloadIndex = overallIndex + direction;
            } else if (direction === -1 && overallIndex <= 0) {
                direction = 1;
                preloadIndex = overallIndex + direction;
            }

            // Preload images if buffer is running low
            preloadImages(); // Call preloadImages to ensure buffer is filled
        } else {
            console.warn('Buffer is empty. Skipping frame update...');
            // Preload images to fill the buffer
            preloadImages();
        }
    }

    requestAnimationFrame(renderLoop);
}

// Function to Draw Images with Aspect Ratio Preservation and Padding
function drawImageWithAspect(context, img) {
    const canvasAspect = context.canvas.width / context.canvas.height;
    const imgAspect = img.width / img.height;

    let drawWidth, drawHeight, offsetX, offsetY;

    if (imgAspect > canvasAspect) {
        // Image is wider than canvas
        drawWidth = context.canvas.width;
        drawHeight = drawWidth / imgAspect;
        offsetX = 0;
        offsetY = (context.canvas.height - drawHeight) / 2;
    } else {
        // Image is taller than canvas
        drawHeight = context.canvas.height;
        drawWidth = drawHeight * imgAspect;
        offsetX = (context.canvas.width - drawWidth) / 2;
        offsetY = 0;
    }

    context.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
}

// Utility Function to Get Random Integer (Inclusive)
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Initialization Function
async function initialize() {
    // Load Folder Lists
    const mainData = await fetchJSON(MAIN_IMAGES_JSON);
    const floatData = await fetchJSON(FLOAT_IMAGES_JSON);

    mainFolders = mainData.folders;
    floatFolders = floatData.folders;

    // Ensure Both Layers Have the Same Number of Folders
    folderCount = Math.min(mainFolders.length, floatFolders.length);
    if (folderCount === 0) {
        console.error('No folders found in one or both JSON files.');
        return;
    }

    // Preload Initial Images
    await preloadImages();

    // Start the Rendering Loop
    requestAnimationFrame(renderLoop);
}

// Start the Initialization
initialize();
